# TaskFlow Pro - Cline Configuration

This file configures Cline (AI coding assistant) to work with TaskFlow Pro following the AI-Assisted Development Framework.

====

DATE HANDLING

Always use the current date from environment_details "Current Time" field, not training data dates.

====

SINGLE SOURCE OF TRUTH

**project_docs/context_master_guide.md**

All project rules, philosophy, workflows, and standards are defined there. This file only configures HOW and WHEN you access that master document.

====

SESSION PROTOCOL

**At session start:**
```
1. MCP tool: get_context_for_task(task_type="session_start")
2. MCP tool: get_current_implementation_status()
3. If fixing/changing existing code:
   - MCP tool: start_change_request(description, change_type, affected_feature, severity)
   - MCP tool: check_pattern_exists(feature_description)
   - Analyze root cause (NO code changes yet)
   - Present hypothesis/plan to user
```

**Before starting new iteration work:**
```
1. MCP tool: get_context_for_task(task_type="cycle_start")
2. MCP tool: check_pattern_exists(feature_description="[what you're building]")
   - If pattern exists: Follow it exactly
   - If no pattern: Plan to document new pattern after implementation
3. Read relevant design docs as identified in the context
```

**During change iteration (fixes/refinements):**
```
- Make code changes and test
- **DO NOT document until user confirms change works**
- Keep iterating until user confirms success
```

**After user confirms change works:**
```
1. MCP tool: validate_change_resolution(change_id)
2. Review COMPLETE documentation checklist returned by tool
3. Create change documentation in bug_fixes/ directory
4. Update ALL affected docs:
   - technical_status.md (ALWAYS - Recently Changed section)
   - patterns/ (if pattern revealed, established, or fixed)
   - workflows/ (if conceptual logic changed)
5. MCP tool: close_change_request(change_id, documentation_file)
6. Present summary showing ALL docs updated
```

**Before marking work complete:**
```
1. MCP tool: get_context_for_task(task_type="cycle_complete")
2. MCP tool: get_completion_checklist()
3. MCP tool: validate_api_contracts(endpoints=[...]) if endpoints modified
4. Review COMPLETE checklist with user
5. Complete Critical Update Sequence:
   - technical_status.md updated
   - patterns/ updated (if new patterns OR pattern applied)
   - implementation_plan.md updated (status → COMPLETE)
6. MCP tool: validate_cycle_completion(cycle="X.X", completed_items=[...])
7. Show validation results to user
8. ONLY THEN use attempt_completion
```

====

DOCUMENT UPDATES

All changes to files in `project_docs/` require:
1. Show diff to user
2. Wait for approval
3. Apply only after approval

====

API CONTRACT STANDARDS (MANDATORY)

**Before creating/modifying ANY API endpoint:**
1. Read project_docs/api_contract_standards.md
2. Define Pydantic response model FIRST
3. Add `response_model` parameter to endpoint
4. Explicitly map service data to response model
5. Regenerate TypeScript types
6. MCP tool: validate_api_contracts(endpoints=[...])

**If endpoint doesn't follow standards:**
- ❌ Reject implementation
- ✅ Fix to match standards
- ✅ Document if intentional deviation

**Contract-First Development:**
- Define API contract BEFORE implementation
- Frontend and backend align on contract
- Changes require contract update first

**NO EXCEPTIONS:**
- ✅ Every endpoint has Pydantic response model
- ✅ Every endpoint explicitly maps to model
- ✅ Frontend uses auto-generated types from types/api.ts
- ✅ No direct fetch() calls (use lib/apiClient.ts)
- ❌ NO manual TypeScript types for API responses

====

CRITICAL RULES

**For API Development (MANDATORY):**
- ALL endpoints MUST use Pydantic response models
- ALL endpoints MUST have `response_model` parameter
- ALL endpoints MUST explicitly map service data to Pydantic model
- Frontend MUST use `apiClient` from `frontend/lib/apiClient.ts`
- Frontend MUST use auto-generated TypeScript types from `frontend/types/api.ts`
- NO direct fetch calls in components - ZERO EXCEPTIONS
- When fixing bugs, ALWAYS check if component uses apiClient and auto-generated types

**For Changes:**
- Never update documentation during iteration
- Only after user confirmation of successful change
- ALWAYS update ALL affected docs, not just the change doc
- Bug fixes go in bug_fixes/ directory with full template

====

For all rules, workflows, and standards, read context_master_guide.md using the MCP tools.